plugins {
    kotlin("jvm") version "1.9.24" apply false

    // Android Plugins
    alias(libs.plugins.androidApplication) apply false
    alias(libs.plugins.kotlinAndroid) apply false
    id("com.google.devtools.ksp") version "2.3.4" apply false
}

allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

tasks.register("applyPatch") {
    group = "tools"
    description = "Applies a multi-file patch generated by Gemini (Repomix format)."

    // 1. 構成フェーズで必要なパスを java.io.File (シリアライズ可能) として確定させる
    // これにより doLast 内で project や layout オブジェクトを参照しなくて済むようにする
    val rootDir = layout.projectDirectory.asFile
    val patchFile = layout.projectDirectory.file("repomix-patch.txt").asFile

    doLast {
        // 2. 実行フェーズ (Configuration Cache に保存される部分)

        if (!patchFile.exists()) {
            throw GradleException("Patch file not found: ${patchFile.absolutePath}\nPlease create 'patch.txt' in the project root.")
        }

        println("Applying patch from: ${patchFile.name}")

        val fileHeaderPattern = Regex("^File:\\s+(.+)$")
        var currentFile: java.io.File? = null
        val contentBuffer = StringBuilder()

        // 3. ヘルパー関数を doLast の内部関数として定義し、Scriptオブジェクトへの参照を切る
        fun writeContent(file: java.io.File, content: String) {
            file.parentFile.mkdirs()
            file.writeText(content)
            println("✅ Updated: ${file.path}")
        }

        patchFile.forEachLine { line ->
            val match = fileHeaderPattern.find(line)
            if (match != null) {
                // 前のファイルがあれば書き込む
                currentFile?.let { file ->
                    writeContent(file, contentBuffer.toString())
                    contentBuffer.clear()
                }

                // 新しいファイルのパスを解決 (rootDir を基点にする)
                val relativePath = match.groupValues[1].trim()
                currentFile = rootDir.resolve(relativePath)
                println("Targeting: $relativePath")
            } else {
                // ファイルパスが見つかるまではバッファしない
                if (currentFile != null) {
                    contentBuffer.append(line).append("\n")
                }
            }
        }

        // 最後のファイルを書き込む
        currentFile?.let { file ->
            writeContent(file, contentBuffer.toString())
        }
    }
}
